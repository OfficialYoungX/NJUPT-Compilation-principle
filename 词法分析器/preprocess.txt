#include <iostream>// #define GLEW_STATIC#include <GL/glew.h>#include <GLFW/glfw3.h>const GLint WIDTH = 800, HEIGHT = -600;//"layout(location = 0) in vec3 position;\n"//"void main()\n"//"gl_Position = vec4( position.x, position.y, position.z, 1.0f);\n"const GLchar *vertexShaderSource = "#version 330 core\n""layout (location = 0) in vec3 aPos;\n""layout (location = 1) in vec3 aColor;\n""out vec3 ourColor;\n""void main()\n""{\n""gl_Position = vec4(aPos, 1.0f);\n""ourColor = aColor;\n""}";//"out vec4 color;\n"//"void main()\n"//"color = vec4(1.0f, 0.5f, 0.2f, 0.7f);\n"const GLchar *fragmentShaderSource = "#version 330 core\n""out vec4 FragColor;\n""in vec3 ourColor;\n""void main()\n""{\n""FragColor = vec4(ourColor, 1.0f);\n""}";int main(){ glfwInit();  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);  glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);    GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "Learn OpenGL IDB16040426", nullptr, nullptr);   int screenWidth , screentHeight; glfwGetFramebufferSize(window, &screenWidth, &screentHeight);    if (nullptr == window) { std::cout << "Failed to create GLFW window" << std::endl; glfwTerminate(); return -1; }  glfwMakeContextCurrent(window);   glewExperimental = GL_TRUE;  if (GLEW_OK != glewInit()){ std::cout<<"Failed to init GLEW"<<std::endl; glfwTerminate(); return -1; }  glViewport(0,0,screenWidth, screentHeight);   GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); glCompileShader(vertexShader);   GLint success; GLchar infoLog[512];  glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl; }  GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); glCompileShader(fragmentShader);  glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl; }  GLuint shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram);   glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout << "ERROR::PROGRAM::FRAGMENT::LINK_FAILED\n" << infoLog << std::endl; }  glDetachShader(shaderProgram, vertexShader); glDetachShader(shaderProgram, fragmentShader);   glDeleteShader(vertexShader); glDeleteShader(fragmentShader);   GLfloat vertices[] = { -0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f };  GLuint VAO, VBO;  glGenVertexArrays(1, &VAO); glGenBuffers(1, &VBO);   glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO);   glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid *)0); glEnableVertexAttribArray(0);   glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (void*)(3* sizeof(float))); glEnableVertexAttribArray(1);   glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);  while (!glfwWindowShouldClose(window)) { glfwPollEvents(); glClearColor(0.2f, 0.3f, 0.3f, 1.0f);  glClear(GL_COLOR_BUFFER_BIT);  glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); glBindVertexArray(0);  glfwSwapBuffers(window); }  glDeleteVertexArrays(1, &VAO); glDeleteBuffers(1, &VAO); glfwTerminate(); return 0;}